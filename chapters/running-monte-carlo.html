<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Unit Square and Inscribed Circle</title>

	<script type="text/javascript" async
	  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>

	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({ TeX: { extensions: ["color.js"] }});
	</script>

	<script src="../js/d3/d3.min.js"></script>
	<script src="../js/util.js"></script>

	<style>
		.axis path {
			fill: transparent;
			stroke: #333;
			opacity: 0.3;
		}

		.axis line {
			fill: transparent;
			stroke: transparent;
		}

		.axis text {
			fill: #333;
			opacity: 0.3;
		}
		
		.math-text {
			position: absolute;
			left: 0;
			top: 0;
		}

		.math-text p {
			position: absolute;
			transform: translate(-25%, -50%)
		}

		button {
			position: absolute;
			bottom: 0;
			left: 0;
			padding: 10px 30px;
			margin: 5px;
			border: 1px solid #ccc;
			background: none;
			border-radius: 5px;
			font-size: 11px;
		}

		button:hover {
			transition: box-shadow 200ms;
			box-shadow: 4px 4px 5px 0px #ccc;
			border: 1px solid #333;
			cursor: pointer;
		}

		.running {
			display: none;
		}


	</style>
</head>
<body>
	<div id="container">
	</div>
	<div id="pi-text" class="math-text"><p></p></div>
	<button class="run-sim">Run</button>

	<script>

		var n, x, y, points, circle, inCircleCount, inCircleProp, piApprox = null;
		function runMCSim(npoints) {
			n = npoints;
			x = buildCustomArray(n, function(){ return randReal(0,1); });
			y = buildCustomArray(n, function(){ return randReal(0,1); });
			points = zip(x,y);

			circle = { point: [0.5, 0.5], r: 0.5 };

			points = vecOp(points, function(d,i){
				var dist = euclideanDist(d, circle.point);
				var indicator = dist <= circle.r ? 1 : 0;
				return { point: d, inCircle: indicator };
			});

			inCircleCount = sum(quickMap(points, "inCircle"));
			inCircleProp = inCircleCount / n;
			piApprox = 4 * inCircleProp;
		}

		var timesRun = 0;

		var simDone = false;

		var piText = d3.select("#pi-text");

		var runButton = d3.select(".run-sim");
		runButton.on("click", function(d,i){
				var me = d3.select(this);
				if (!me.classed("running")) {
					me.classed("running", true);
					simDone = false;
					timesRun += 1;

					if (timesRun > 1) {
						resetPoints()
					}
					else {
						buildRect();
					}
				}
			})

		width = 940;
		height = 320;
		margin = 10;
		var div = d3.select("#container");
		var svg = div.append("svg")
				.attr("width", width + 2 * margin)
				.attr("height", height + 2 * margin)
			.append("g")
				.attr("transform", "translate(" + margin + "," + margin + ")")


		var circle = { point: [0.5, 0.5], r: 0.5 };
		var square = { width: 300, height: 300 };

		var xscale = d3.scaleLinear()
			.domain([0,1])
			.range([0, square.width]);

		var yscale = d3.scaleLinear()
			.domain([0,1])
			.range([0, square.height]);

		var xoff = function(val) {
			return val + (width - square.width) / 2;
		}

		piText
			.style("left", xscale(0.5) + "px")
			.style("top", yscale(0.5) + "px")
			.style("font-size", "20px")
			.style("opacity", 0);

		function resetPoints() {
			svg.selectAll(".points").remove();
			piText.style("opacity", 0);
			runMCSim(10000);
			var pi_html = "<p>\\( \\definecolor{bluePi}{RGB}{0,153,255} \\pi \\approx 4 \\left( \\frac{\\color{bluePi}{" + inCircleCount + "}}{" + n + "} \\right) \\approx" + piApprox + "\\)</p>"
			queueMathJax(pi_html, piText.node());

			setTimeout(buildPoints, 300);
			// buildPoints();
		}

		function buildRect() {
			svg.selectAll("*").remove();
			piText.style("opacity", 0);
			runMCSim(10000);
			var pi_html = "<p>\\( \\definecolor{bluePi}{RGB}{0,153,255} \\pi \\approx 4 \\left( \\frac{\\color{bluePi}{" + inCircleCount + "}}{" + n + "} \\right) \\approx" + piApprox + "\\)</p>"
			queueMathJax(pi_html, piText.node());

			svg.append("rect")
					.attr("class", "unit-square")
					.attr("x", xoff(xscale(0)))
					.attr("width", xscale(1) - xscale(0))
					.attr("y", yscale(0))
					.attr("height", yscale(1) - yscale(0))
					.attr("fill", "transparent")
					.attr("stroke", "transparent")
				.transition()
					.delay(500)
					.duration(1000)
					.attr("stroke", "black")
					.attr("fill", "black")
					.attr("fill-opacity", 0.05)
				.on("end", inscribeCircle);
			}

		function inscribeCircle(){
			svg.append("circle")
					.attr("class", "inscribed-circle")
					.attr("cx", xoff(xscale(circle.point[0])))
					.attr("cy", yscale(circle.point[1]))
					.attr("r", xscale(circle.r))
					.attr("fill", "transparent")
					.attr("stroke", "transparent")
					.attr("fill-opacity", 0)
				.transition()
					.duration(1500)
					.attr("fill", "#0099ff")
					.attr("fill-opacity", 0.1)
					.attr("stroke", "#0099ff")
				.on("end", buildPoints);
		}

		function buildPoints() {
			svg.selectAll(".points").data(points)
				.enter().append("circle")
					.attr("class", "points")
					.attr("cx", function(d,i){ return xoff(xscale(d.point[0])); })
					.attr("cy", function(d,i){ return xscale(d.point[1]); })
					.attr("r", 1)
					.attr("fill", "transparent")
				.transition()
					.delay(function(d,i){ return i * 4000 / points.length; })
					.duration(200)
					.attr("fill", function(d,i){ return d.inCircle == 1 ? "#0099ff" : "black"; })
				.call(endall, resetSim)
					// .attr("fill", "black")
				// .on("end", inscribeCircle);

		}

		function resetSim() {
			piText
				.transition()
					.duration(1000)
					.style("opacity", 1);

			simDone = true;
			runButton.classed("running", false);
		}

	</script>
</body>
</html>